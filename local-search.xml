<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>JAVA VIRTUAL MACHINE</title>
    <link href="/2021/08/19/JAVA-VIRTUAL-MACHINE/"/>
    <url>/2021/08/19/JAVA-VIRTUAL-MACHINE/</url>
    
    <content type="html"><![CDATA[<h2 id="虚拟机栈"><a href="#虚拟机栈" class="headerlink" title="虚拟机栈"></a>虚拟机栈</h2><p>Java virtual machine stack </p><p>栈内存是线程私有的</p><p>有一个方法则产生一个栈帧</p><p>-Xss是修改线程大小(栈帧大小)的值</p><p>如果一个局部变量没有逃离方法的作用范围,它是线程安全的,反之则不行</p><h3 id="问题1-cpu使用过多如何排查"><a href="#问题1-cpu使用过多如何排查" class="headerlink" title="问题1:cpu使用过多如何排查"></a>问题1:cpu使用过多如何排查</h3><p>ps H -eo pid,tid,%cpu|grep 进程id</p><p>查看线程</p><p>jstack 进程id</p><p>​    可以根据线程id找到有问题的线程,进一步定位奥问题代码的源码行号</p><h3 id="问题2-程序运行很久之后没有结果如何排查"><a href="#问题2-程序运行很久之后没有结果如何排查" class="headerlink" title="问题2:程序运行很久之后没有结果如何排查"></a>问题2:程序运行很久之后没有结果如何排查</h3><p>jstack 进程id</p><p>查看最后的输出</p><p>查看发生死锁的地方(deadlock)</p><h2 id="本地方法栈"><a href="#本地方法栈" class="headerlink" title="本地方法栈"></a>本地方法栈</h2><p>native</p><p>因为jvm隔绝了底层操作系统</p><p>本地方法栈就是调用底层的方法</p><p>放在本地方法栈</p><h2 id="堆内存"><a href="#堆内存" class="headerlink" title="堆内存"></a>堆内存</h2><p>通过new关键字,创建对象都会使用堆内存</p><p>特点</p><ul><li><p>他是线程共享的,堆中对象都要考虑线程安全问题</p></li><li><p>有垃圾回收机制</p></li></ul><p>堆内存溢出</p><p>-Xmx 用于设置heap中内存的最大值</p><p>排查堆内存的问题:设置堆内存大小小一点</p><p>堆内存诊断工具</p><p>jps工具</p><ul><li>查看当前系统中有哪些java进程</li></ul><p>jmap工具</p><ul><li>查看堆内存占用情况</li></ul><p>jconsole工具</p><ul><li>图形界面的,多功能的监测工具,可以连续监测</li></ul><p>jvisualvm工具</p><h3 id="方法区-Method-Area"><a href="#方法区-Method-Area" class="headerlink" title="方法区(Method Area)"></a>方法区(Method Area)</h3><p>概念上是堆的一部分</p><p>方法区只是一种概念,(hotspot)1.6之前的实现是叫永久代,堆空间的一部分,1.8之后实现方式叫元空间(metaspace),使用到了本地内存(include:其他进程,metaspace)</p><p>PermGen中</p><p>-XX:MaxPermSize = 8m</p><p>meta space 中</p><p>-XX:MaxMetaspaceSize = 8m</p><p>场景</p><p>spring</p><p>mybatis</p><h4 id="常量池-constand-pool"><a href="#常量池-constand-pool" class="headerlink" title="常量池(constand pool)"></a>常量池(constand pool)</h4><p>StringTable特性</p><ul><li>常量池中的字符仅仅只是符号,第一次用到时才变为对象</li><li>避免重复创造字符串</li><li>字符串拼接原理StringBuilder(1.8),makeConcatwithContents(9以后)</li><li>字符串拼接的原理是编译期优化</li><li>可以使用intern方法,主动将串池中没有的字符串对象放入串池</li></ul><p>使用 javap -v class文件名</p><p>查看常量池中的相关操作信息</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo5</span> </span>&#123;<br>    <span class="hljs-comment">//运行时常量池中的信息,都会被加载到运行时常量池中,都是常量池中的符号,还没有变成java字符串对象</span><br>    <span class="hljs-comment">//ldc #7 会把 a 符号变为 &quot;a&quot; 字符串对象</span><br>    <span class="hljs-comment">//ldc #9 会把 a 符号变为 &quot;b&quot; 字符串对象</span><br>    <span class="hljs-comment">//ldc #11 会把 a 符号变为 &quot;ab&quot; 字符串对象</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        String s1 = <span class="hljs-string">&quot;a&quot;</span>;<span class="hljs-comment">//懒惰的</span><br>        String s2 = <span class="hljs-string">&quot;b&quot;</span>;<br>        String s3 = <span class="hljs-string">&quot;ab&quot;</span>;<br>        String s4 = s1+s2;<span class="hljs-comment">//结果不确定,所以要动态拼接,jdk8是StringBuilder,jdk9开始是makeConcatwithContents</span><br>        String s5 = <span class="hljs-string">&quot;a&quot;</span>+<span class="hljs-string">&quot;b&quot;</span>;<span class="hljs-comment">//确定的结果,javac在编译期间的优化,结果已经在编译期间确定为ab</span><br>        System.out.println(s3==s5);<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>可以用intern方法将字符串放入StringTable中(1.8以后)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo7</span> </span>&#123;<br>    <span class="hljs-comment">//StringTable:&#123;a,b,ab&#125;(1)</span><br>    <span class="hljs-comment">//StringTable:&#123;ab,a,b&#125;</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        String x = <span class="hljs-string">&quot;ab&quot;</span>;<br>        String s = <span class="hljs-keyword">new</span> String(<span class="hljs-string">&quot;a&quot;</span>)+<span class="hljs-keyword">new</span> String(<span class="hljs-string">&quot;b&quot;</span>);<span class="hljs-comment">//new String&#123;a,b&#125;</span><br>        <span class="hljs-comment">//堆 new String(&quot;a&quot;) new String(&quot;b&quot;) new String(&quot;ab&quot;),是堆中创立的对象</span><br>        String s1 = s.intern();<span class="hljs-comment">//将&quot;ab&quot;放入串池中,有则不放,没有则放,s1 是串池中创建的</span><br>        System.out.println(s==<span class="hljs-string">&quot;ab&quot;</span>);<span class="hljs-comment">//s在堆中因为,已经有了所以不放入</span><br>        System.out.println(s1==<span class="hljs-string">&quot;ab&quot;</span>);<span class="hljs-comment">//串池中已经有了ab,s不放入,</span><br>        <span class="hljs-comment">//结果</span><br>        <span class="hljs-comment">//false</span><br>       <span class="hljs-comment">//true</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>1.6的时候</p><p>将这个字符串对象尝试放入串池,如果有则放入,没有则不放入,但是会new一份放入串池</p><p>在1.6中StringTable放在永久代中(此时永久代也在heap中)</p><p>1.7以后开始放在堆中(heap  include StringTabler),而此时方法区的实现在本地内存中,被叫做元空间(meta space) (class,classLoader,常量池)</p><h3 id="StringTable会发生垃圾回收"><a href="#StringTable会发生垃圾回收" class="headerlink" title="StringTable会发生垃圾回收"></a>StringTable会发生垃圾回收</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 演示StringTable垃圾回收</span><br><span class="hljs-comment"> * -Xmx10m -XX:+PrintStringTableStatistics -Xlog:gc* -verbose:gc</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo9</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">1000000</span>; j++) &#123;<br>                String.valueOf(j).intern();<br>                i++;<br>            &#125;<br>        &#125;<span class="hljs-keyword">catch</span> (Throwable e)&#123;<br>            e.printStackTrace();<br>        &#125;<span class="hljs-keyword">finally</span> &#123;<br>            System.out.println(i);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="StringTable性能调优"><a href="#StringTable性能调优" class="headerlink" title="StringTable性能调优"></a>StringTable性能调优</h2><p>-XX:StringTableSize=桶个数;</p><p>设置StringTable中桶的数量以提高运行速度(减少hash碰撞)</p><p>考虑字符串对象是否入池</p><h2 id="直接内存"><a href="#直接内存" class="headerlink" title="直接内存"></a>直接内存</h2><p>属于操作系统内存,不受java虚拟机的管理</p><p>使用unsafe对象进行直接内存的分配回收,并且回收需要主动调用freeMemory方法</p><p>ByteBuffer的实现内部,使用了Cleaner(虚引用 phantomReference)来监测ByteBuffer对象,一旦ByteBuffer对象被垃圾回收,那么就会由Reference线程通过Cleaner的clean方法调用freeMemory来释放直接内存</p><p>建议使用unsafe.freeMemory() 来进行回收直接内存而不是system.gc();</p>]]></content>
    
    
    
    <tags>
      
      <tag>JVM jvm</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Netty-doc</title>
    <link href="/2021/08/18/Netty-doc/"/>
    <url>/2021/08/18/Netty-doc/</url>
    
    <content type="html"><![CDATA[<h1 id="Netty-translate"><a href="#Netty-translate" class="headerlink" title="Netty-translate"></a>Netty-translate</h1><ol><li><p><a href="https://netty.io/4.1/api/io/netty/channel/nio/NioEventLoopGroup.html"><code>NioEventLoopGroup</code></a> is a multithreaded event loop that handles I/O operation. Netty provides various <a href="https://netty.io/4.1/api/io/netty/channel/EventLoopGroup.html"><code>EventLoopGroup</code></a> implementations for different kind of transports. We are implementing a server-side application in this example, and therefore two <a href="https://netty.io/4.1/api/io/netty/channel/nio/NioEventLoopGroup.html"><code>NioEventLoopGroup</code></a> will be used. The first one, often called ‘boss’, accepts an incoming connection. The second one, often called ‘worker’, handles the traffic of the accepted connection once the boss accepts the connection and registers the accepted connection to the worker. How many Threads are used and how they are mapped to the created <a href="https://netty.io/4.1/api/io/netty/channel/Channel.html"><code>Channel</code></a>s depends on the <a href="https://netty.io/4.1/api/io/netty/channel/EventLoopGroup.html"><code>EventLoopGroup</code></a> implementation and may be even configurable via a constructor.</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs tex">Nio事件循环组是一个处理I/O操作的多线程事件循环,Netty 给不同的运输工具提供了丰富的事件循环组实现.我们在这个例子中实现了一个服务器端程序,因此要用到两个Nio事件循环组.第一个通常叫做&#x27;boss&#x27;,接收一个刚进入的连接.<br><br>第二个(事件循环组)通常叫做&#x27;worker&#x27;,当boss接收连接然后将连接注册给worker,(woeker)用来处理被接受的连接交易(运输).<br><br>有多少线程被使用以及他们怎样传递信息给所创建的通道取决于事件循环组的实现甚至可能是构造器的配置<br></code></pre></td></tr></table></figure></li><li><p><a href="https://netty.io/4.1/api/io/netty/bootstrap/ServerBootstrap.html"><code>ServerBootstrap</code></a> is a helper class that sets up a server. You can set up the server using a <a href="https://netty.io/4.1/api/io/netty/channel/Channel.html"><code>Channel</code></a> directly. However, please note that this is a tedious process, and you do not need to do that in most cases.</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs tex">服务器引导是一个用来搭建服务器的帮助类.<br><br>你可以使用一个通道直接搭建一个服务器(server)<br><br>然而,请记住这是一个令人乏味的过程,大多数情况下您不需要这样做<br><br><br><br></code></pre></td></tr></table></figure></li><li><p>Here, we specify to use the <a href="https://netty.io/4.1/api/io/netty/channel/socket/nio/NioServerSocketChannel.html"><code>NioServerSocketChannel</code></a> class which is used to instantiate a new <a href="https://netty.io/4.1/api/io/netty/channel/Channel.html"><code>Channel</code></a> to accept incoming connections.</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs tex">这里,我们指定使用Nio服务器套接字通道类用来实例化一个新通道来接收新进来的连接<br></code></pre></td></tr></table></figure></li><li><p>The handler specified here will always be evaluated by a newly accepted <a href="https://netty.io/4.1/api/io/netty/channel/Channel.html"><code>Channel</code></a>. The <a href="https://netty.io/4.1/api/io/netty/channel/ChannelInitializer.html"><code>ChannelInitializer</code></a> is a special handler that is purposed to help a user configure a new <a href="https://netty.io/4.1/api/io/netty/channel/Channel.html"><code>Channel</code></a>. It is most likely that you want to configure the <a href="https://netty.io/4.1/api/io/netty/channel/ChannelPipeline.html"><code>ChannelPipeline</code></a> of the new <a href="https://netty.io/4.1/api/io/netty/channel/Channel.html"><code>Channel</code></a> by adding some handlers such as <code>DiscardServerHandler</code> to implement your network application. As the application gets complicated, it is likely that you will add more handlers to the pipeline and extract this anonymous class into a top-level class eventually.</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs tex">这里这个被指定的处理程序将始终由新接收的通道进行评估<br><br>通道初始化器是一个特殊的处理程序目的是为了帮助使用者配置一个新通道<br><br>您很可能希望通过添加一些处理程序（如DiscardServerHandler）来配置新通道的通道管道，以实现网络应用程序。<br><br>随着应用程序变得复杂，您可能会向管道中添加更多处理程序，并最终将该匿名类提取到顶级类中。<br></code></pre></td></tr></table></figure></li><li><p>You can also set the parameters which are specific to the <code>Channel</code> implementation. We are writing a TCP/IP server, so we are allowed to set the socket options such as <code>tcpNoDelay</code> and <code>keepAlive</code>. Please refer to the apidocs of <a href="https://netty.io/4.1/api/io/netty/channel/ChannelOption.html"><code>ChannelOption</code></a> and the specific <a href="https://netty.io/4.1/api/io/netty/channel/ChannelConfig.html"><code>ChannelConfig</code></a> implementations to get an overview about the supported <code>ChannelOption</code>s.</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs tex">您可以给指定的通道实现设置参数<br><br>我们写了TCP/IP服务器,所以允许我们设置套接字选项例如 tcpnodelay 和 keepAlive<br><br>请根据 通道选择的 api文档 以及指定的通道配置实现 来概览被支持的通道选项<br></code></pre></td></tr></table></figure></li><li><p>Did you notice <code>option()</code> and <code>childOption()</code>? <code>option()</code> is for the <a href="https://netty.io/4.1/api/io/netty/channel/socket/nio/NioServerSocketChannel.html"><code>NioServerSocketChannel</code></a> that accepts incoming connections. <code>childOption()</code> is for the <a href="https://netty.io/4.1/api/io/netty/channel/Channel.html"><code>Channel</code></a>s accepted by the parent <a href="https://netty.io/4.1/api/io/netty/channel/ServerChannel.html"><code>ServerChannel</code></a>, which is <a href="https://netty.io/4.1/api/io/netty/channel/socket/nio/NioSocketChannel.html"><code>NioSocketChannel</code></a> in this case.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs text">你注意到了选项和子选项了吗?选项是为了Nio服务套接字通道来接收进入的连接的.<br><br>子选项是给父服务通道所接收的通道的,在本例中是NioSocketChannel<br><br><br></code></pre></td></tr></table></figure></li><li><p>We are ready to go now. What’s left is to bind to the port and to start the server. Here, we bind to the port <code>8080</code> of all NICs (network interface cards) in the machine. You can now call the <code>bind()</code> method as many times as you want (with different bind addresses.)</p></li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs text">我们准备好开始了,最后剩下的就是绑定接口然后启动这个服务器.<br><br>这里,我们给所有的网络接口卡绑定8080这个端口号<br><br>你可以现在调用bind()方法任意次数(以不同的绑定地址)<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
